// api/audit.ts
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { createClient } from '@supabase/supabase-js';
import { createHash, randomUUID } from 'crypto';
import { LoggingSource } from '@/types/loggingsource';
import { FinancialInput, KeyFacts } from '@/types';

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const ALLOWED_ORIGINS = process.env.ALLOWED_ORIGINS?.split(',').map(o => o.trim()) || [];
const DISCLOSURE_VERSION = process.env.DISCLOSURE_VERSION;
const ALERT_COPY_VERSION = process.env.ALERT_COPY_VERSION;
const SURVEY_SCHEMA_VERSION = process.env.SURVEY_SCHEMA_VERSION;

/**
 * Type for inserting audit records into Supabase wealth_audit_logs table
 * Note: id and created_at are auto-generated by Supabase, so they're not included here
 */
export interface WealthAuditLogInsert {
    payload_hash: string;
    source: string;
    engine_version: string | null;
    alert_copy_version: string | null;
    survey_schema_version: string | null;
    disclosure_version: string | null;
    consent: Record<string, any> | null;
    ip: string | null;
    user_agent: string | null;
    lead_email: string | null;
    lead_phone: string | null;
    lead_first_name: string | null;
    lead_last_name: string | null;
    raw_input: FinancialInput | null;
    derived: Record<string, any> | null;
    key_facts: KeyFacts | null;
    triggered_alert_ids: string[] | null;
    presented_alert_ids: string[] | null;
    public_insights: Array<{
      title: string;
      description: string;
      status: 'critical' | 'warning' | 'good' | 'info';
    }> | null;
  }

  
/**
 * Hash payload for audit tracking (used for payload_hash column)
 */
function hashPayload(payload: any): string {
  return createHash('sha256').update(JSON.stringify(payload)).digest('hex');
}

/**
 * Get client IP address from request
 */
function getClientIP(req: VercelRequest): string {
  // Check various headers for IP (Vercel uses x-forwarded-for)
  const forwarded = req.headers['x-forwarded-for'];
  if (forwarded) {
    const ips = Array.isArray(forwarded) ? forwarded[0] : forwarded;
    return ips.split(',')[0].trim();
  }
  
  const realIP = req.headers['x-real-ip'];
  if (realIP) {
    return Array.isArray(realIP) ? realIP[0] : realIP;
  }
  
  // Fallback to connection remote address
  return req.socket?.remoteAddress || 'unknown';
}

/**
 * Validate origin if configured
 */
function validateOrigin(req: VercelRequest): boolean {
  if (ALLOWED_ORIGINS.length === 0) {
    // No origin validation configured, allow all
    return true;
  }
  
  const origin = req.headers.origin || req.headers.referer;
  if (!origin) {
    return false;
  }
  
  try {
    const originUrl = new URL(origin);
    const originHost = originUrl.origin;
    
    return ALLOWED_ORIGINS.some(allowed => {
      try {
        const allowedUrl = new URL(allowed);
        return allowedUrl.origin === originHost;
      } catch {
        // If allowed origin is not a full URL, compare as string
        return allowed === originHost || allowed === origin;
      }
    });
  } catch {
    return false;
  }
}

/**
 * Create reduced payload for Zapier (excludes sensitive data)
 */
function createReducedPayload(data: any): any {
  const {
    source,
    clientTimestamp,
    lead,
    keyFacts,
    presentedAlertIds,
    engineVersion,
    versions
  } = data;
  
  return {
    timestamp: clientTimestamp || new Date().toISOString(),
    source,
    lead: lead ? {
      firstName: lead.firstName,
      lastName: lead.lastName,
      email: lead.email,
      phone: lead.phone
    } : undefined,
    keyFacts,
    presentedAlertIds,
    engineVersion,
    versions
  };
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  // Only accept POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed. Use POST.' });
  }

  // Validate origin if configured
  if (!validateOrigin(req)) {
    return res.status(403).json({ error: 'Origin not allowed' });
  }

  // Check required environment variables
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    console.error('Missing required environment variables: SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
    return res.status(500).json({ error: 'Server configuration error' });
  }

  try {
    const payload = req.body;
    const clientIP = getClientIP(req);
    const payloadHash = hashPayload(payload);

    // Create Supabase client with service role key (bypasses RLS)
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    });

    // Extract fields from payload structure
    const {
      source,
      lead,
      keyFacts,
      compliance,
      publicInsights,
      versions,
      consent
    } = payload;

    // Prepare audit record matching Supabase schema
    const auditRecord: WealthAuditLogInsert & { id: string } = {
      id: randomUUID(),
      payload_hash: payloadHash,
      source: source as LoggingSource,
      ip: clientIP,
      user_agent: req.headers['user-agent'] || null,
      // Lead information (extracted from lead object)
      lead_email: lead?.email || null,
      lead_phone: lead?.phone || null,
      lead_first_name: lead?.firstName || null,
      lead_last_name: lead?.lastName || null,
      // Compliance fields
      engine_version: compliance?.engineVersion || null,
      alert_copy_version: ALERT_COPY_VERSION || null,
      survey_schema_version: SURVEY_SCHEMA_VERSION || null,
      disclosure_version: DISCLOSURE_VERSION || null,
      consent: consent || null,
      // Data fields (from compliance object)
      raw_input: compliance?.rawInput || null,
      derived: compliance?.derived || null,
      key_facts: keyFacts || null,
      triggered_alert_ids: compliance?.triggeredAlertIds || null,
      presented_alert_ids: compliance?.presentedAlertIds || null,
      public_insights: publicInsights || null,
    };

    // Insert into Supabase
    const { data: insertData, error: insertError } = await supabase
      .from('wealth_audit_logs')
      .insert(auditRecord)
      .select()
      .single();

    if (insertError) {
      console.error('Supabase insert error:', insertError);
      throw res.status(500).json({ error: 'Failed to store audit record', details: insertError.message });
    }
    return res.status(200).json({ message: 'Audit record stored successfully' });
  } catch (err) {
    console.error('Audit endpoint error:', err);
    throw res.status(500).json({ error: 'Internal server error' });
  }
}

